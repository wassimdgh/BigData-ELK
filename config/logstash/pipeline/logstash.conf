input {
  # Input pour fichiers CSV uploadés
  file {
    path => "/data/uploads/*.csv"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    type => "iot-csv"
  }

  # Input pour fichiers JSON uploadés
  file {
    path => "/data/uploads/*.json"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    codec => "json"
    type => "iot-json"
  }

  # Input TCP pour streaming en temps réel
  tcp {
    port => 5000
    codec => json_lines
    type => "iot-stream"
  }
}

filter {
  # Traitement des fichiers CSV
  if [type] == "iot-csv" {
    csv {
      separator => ","
      columns => ["timestamp", "sensor_id", "sensor_type", "zone", "value", "unit", "status", "building_id"]
      skip_header => true
    }

    # Conversion du timestamp
    date {
      match => ["timestamp", "ISO8601", "yyyy-MM-dd HH:mm:ss", "yyyy-MM-dd'T'HH:mm:ss.SSSZ"]
      target => "@timestamp"
    }

    # Conversion des valeurs numériques
    mutate {
      convert => {
        "value" => "float"
      }
      strip => ["sensor_id", "sensor_type", "zone", "unit", "status"]
    }

    # Ajout de champs calculés
    if [sensor_type] == "temperature" {
      if [value] > 30 {
        mutate {
          add_field => { "alert_level" => "high" }
          add_field => { "alert_message" => "Température élevée détectée" }
        }
      } else if [value] < 15 {
        mutate {
          add_field => { "alert_level" => "low" }
          add_field => { "alert_message" => "Température basse détectée" }
        }
      } else {
        mutate {
          add_field => { "alert_level" => "normal" }
        }
      }
    }

    if [sensor_type] == "co2" {
      if [value] > 1000 {
        mutate {
          add_field => { "alert_level" => "critical" }
          add_field => { "alert_message" => "Niveau CO2 critique" }
        }
      } else {
        mutate {
          add_field => { "alert_level" => "normal" }
        }
      }
    }

    # Géolocalisation simulée basée sur la zone
    if [zone] == "zone_a" {
      mutate {
        add_field => { "[location][lat]" => "48.8566" }
        add_field => { "[location][lon]" => "2.3522" }
      }
    } else if [zone] == "zone_b" {
      mutate {
        add_field => { "[location][lat]" => "48.8576" }
        add_field => { "[location][lon]" => "2.3532" }
      }
    }
  }

  # Traitement des fichiers JSON
  if [type] == "iot-json" {
    # Le parsing JSON est déjà fait par le codec
    
    date {
      match => ["timestamp", "ISO8601"]
      target => "@timestamp"
    }

    mutate {
      convert => {
        "value" => "float"
      }
    }
  }

  # Enrichissement commun pour tous les types
  mutate {
    add_field => { 
      "ingestion_timestamp" => "%{@timestamp}"
      "pipeline_version" => "1.0"
    }
    remove_field => ["path", "host", "message"]
  }

  # Gestion des erreurs de parsing
  if "_csvparsefailure" in [tags] {
    mutate {
      add_tag => ["parse_error"]
      add_field => { "error_type" => "csv_parse_failure" }
    }
  }
}

output {
  # Output vers Elasticsearch
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "iot-logs-%{+YYYY.MM.dd}"
    document_type => "_doc"
  }

  # Output vers console pour debug
  stdout {
    codec => rubydebug
  }
}
